** Content



#+begin_src md
# Git Hooks 自动版本号递增系统

本文档详细说明了项目中 Git Hooks 自动版本号递增系统的工作原理、涉及的文件以及如何正确配置。

## 🔄 系统工作原理

### 1. 触发机制
```bash
git commit -m "your message"
    ↓
.git/hooks/pre-commit 被触发
    ↓
检查是否应该跳过版本递增
    ↓
调用 scripts/bump-version.sh
    ↓
更新所有版本相关文件
    ↓
将更新的文件添加到当前提交
```

### 2. 核心组件

#### A. Pre-commit Hook (`.git/hooks/pre-commit`)
**作用**: 在每次提交前自动触发版本号递增

**关键逻辑**:
```bash
# 1. 检测跳过条件
if [ "$SKIP_VERSION_BUMP" = "true" ]; then
    exit 0
fi

# 2. 智能检测是否应该跳过
VERSION_FILES="package\.json|tauri\.conf\.json|Cargo\.toml|PKGBUILD|snapcraft\.yaml|winget-manifests/"
DOC_FILES="README\.md|docs/.*\.md|\.md$"
ICON_FILES="icons/.*|\.png$|\.ico$|\.icns$"

# 3. 调用版本递增脚本
NEW_VERSION=$(SILENT_MODE=true "$BUMP_SCRIPT_PATH" 2>/dev/null)

# 4. 将更新的文件添加到暂存区
git add [版本相关文件列表]
```

#### B. 版本递增脚本 (`scripts/bump-version.sh`)
**作用**: 实际执行版本号更新逻辑

**核心功能**:
- 从 `package.json` 读取当前版本
- 递增 patch 版本号 (0.1.47 → 0.1.48)
- 同步更新所有相关文件

## 📁 涉及的文件系统

### 1. 版本源文件
```
package.json                           # 主版本源 (version: "0.1.47")
```

### 2. 需要同步版本号的文件
```
# JavaScript/Node.js 项目文件
├── package.json                       # 根目录主配置
├── apps/desktop/package.json          # Desktop 应用配置
├── apps/web/package.json              # Web 应用配置

# Tauri 相关文件
├── apps/desktop/src-tauri/tauri.conf.json  # Tauri 配置
├── apps/desktop/src-tauri/Cargo.toml       # Rust 项目配置

# 包管理器配置文件
├── aur/PKGBUILD                       # Arch Linux 包配置
├── aur/PKGBUILD-binary                # Arch Linux 二进制包配置
├── snap/snapcraft.yaml               # Snap 包配置
├── flatpak/com.lotus.NovelEditor.yml  # Flatpak 包配置

# Windows 包管理器配置
├── winget-manifests/Jeason.NovelEditor.yaml
├── winget-manifests/Jeason.NovelEditor.installer.yaml
└── winget-manifests/Jeason.NovelEditor.locale.zh-CN.yaml
```

### 3. Git Hook 配置文件
```
.git/hooks/pre-commit                 # Pre-commit hook 脚本
scripts/bump-version.sh               # 版本递增逻辑脚本
```

## 🛠️ 如何添加新的版本同步文件

### 步骤 1: 在 `scripts/bump-version.sh` 中添加更新函数

```bash
# 函数：更新新文件类型的版本号
update_newfile_version() {
    local file=$1
    local new_version=$2

    if [ ! -f "$file" ]; then
        echo -e "${YELLOW}警告: 文件不存在，跳过: $file${NC}"
        return 1
    fi

    # 根据文件格式使用相应的 sed 命令
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS 版本
        sed -i '' "s/version: .*/version: $new_version/" "$file"
    else
        # Linux 版本
        sed -i "s/version: .*/version: $new_version/" "$file"
    fi

    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

### 步骤 2: 在两个模式中调用更新函数

```bash
# 在非静默模式中添加 (约第 270 行)
# 11. 新文件类型
update_newfile_version "$PROJECT_ROOT/path/to/newfile.ext" "$NEW_VERSION" >&2

# 在静默模式中添加 (约第 285 行)
update_newfile_version "$PROJECT_ROOT/path/to/newfile.ext" "$NEW_VERSION" >/dev/null 2>&1
```

### 步骤 3: 在 `.git/hooks/pre-commit` 中添加文件到暂存区

```bash
git add \
    package.json \
    apps/desktop/package.json \
    # ... 其他现有文件 ...
    path/to/newfile.ext \              # 添加新文件
    winget-manifests/*.yaml 2>/dev/null || true
```

### 步骤 4: 更新跳过检测逻辑 (如果需要)

如果新文件应该被跳过检测逻辑识别，更新正则表达式：

```bash
VERSION_FILES="package\.json|tauri\.conf\.json|Cargo\.toml|PKGBUILD|snapcraft\.yaml|winget-manifests/|newfile\.ext"
```

## 🚫 如何避免循环递增问题

### 问题原因
1. 版本文件被更新但未添加到暂存区
2. IDE 自动格式化触发新的提交
3. 形成无限循环

### 解决方案

#### 1. 确保所有版本文件都被添加到暂存区
```bash
# 在 .git/hooks/pre-commit 中
git add \
    [所有版本相关文件] \
    2>/dev/null || true
```

#### 2. 智能跳过检测
```bash
# 检查暂存区文件类型
STAGED_CHANGES=$(git diff --cached --name-only)

# 定义文件类型
VERSION_FILES="package\.json|tauri\.conf\.json|..."
DOC_FILES="README\.md|docs/.*\.md|\.md$"
ICON_FILES="icons/.*|\.png$|\.ico$|\.icns$"

# 如果只有这些类型的文件，跳过版本递增
if echo "$STAGED_CHANGES" | grep -v -E "($VERSION_FILES|$DOC_FILES|$ICON_FILES)" | grep -q .; then
    # 有其他类型文件，继续版本递增
    :
else
    # 只有版本/文档/图标文件，跳过
    exit 0
fi
```

#### 3. 手动跳过机制
```bash
# 临时跳过版本递增
SKIP_VERSION_BUMP=true git commit -m "docs: update documentation"

# 或设置环境变量
export SKIP_VERSION_BUMP=true
git commit -m "fix: version files only"
unset SKIP_VERSION_BUMP
```

## 📋 常见文件类型的更新函数模板

### JSON 文件 (package.json, tauri.conf.json)
```bash
update_json_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/\"version\":\s*\"[^\"]*\"/\"version\": \"$new_version\"/g" "$file"
    else
        sed -i "s/\"version\":\s*\"[^\"]*\"/\"version\": \"$new_version\"/g" "$file"
    fi
}
```

### YAML 文件 (snapcraft.yaml)
```bash
update_yaml_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^version: .*/version: '$new_version'/" "$file"
    else
        sed -i "s/^version: .*/version: '$new_version'/" "$file"
    fi
}
```

### TOML 文件 (Cargo.toml)
```bash
update_toml_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^version = \"[^\"]*\"/version = \"$new_version\"/" "$file"
    else
        sed -i "s/^version = \"[^\"]*\"/version = \"$new_version\"/" "$file"
    fi
}
```

### Shell 脚本文件 (PKGBUILD)
```bash
update_shell_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^pkgver=.*/pkgver=$new_version/" "$file"
    else
        sed -i "s/^pkgver=.*/pkgver=$new_version/" "$file"
    fi
}
```

## 🔍 调试和故障排除

### 1. 检查当前版本号
```bash
# 查看主版本号
grep '"version"' package.json

# 查看所有版本文件的版本号
grep -r "0\.1\." package.json apps/*/package.json aur/PKGBUILD* snap/snapcraft.yaml
```

### 2. 手动测试版本递增
```bash
# 直接运行版本递增脚本
./scripts/bump-version.sh

# 静默模式测试
SILENT_MODE=true ./scripts/bump-version.sh
```

### 3. 检查 Git Hook 状态
```bash
# 检查 pre-commit hook 是否可执行
ls -la .git/hooks/pre-commit

# 如果不可执行，添加执行权限
chmod +x .git/hooks/pre-commit
```

### 4. 查看暂存区状态
```bash
# 查看暂存区文件
git diff --cached --name-only

# 查看具体更改
git diff --cached
```

## 🎯 最佳实践

### 1. 提交消息规范
```bash
# 会触发版本递增的提交
git commit -m "feat: add new feature"
git commit -m "fix: resolve bug"
git commit -m "refactor: improve code structure"

# 不会触发版本递增的提交 (只有版本文件)
git commit -m "chore: update version to 0.1.48"
```

### 2. 批量操作
```bash
# 更新图标后的完整流程
npm run icons:update          # 更新图标
git add .                     # 添加所有更改
git commit -m "feat: update application icons"  # 自动递增版本
```

### 3. 发布流程
```bash
# 1. 开发完成后提交
git commit -m "feat: implement new feature"  # 版本自动递增

# 2. 创建发布标签
npm run tag:desktop           # 创建 desktop-v0.1.X 标签

# 3. 推送到远程
git push origin main --tags   # 推送代码和标签
```

## 📚 相关文件参考

- `.git/hooks/pre-commit` - Pre-commit hook 脚本
- `scripts/bump-version.sh` - 版本递增逻辑
- `package.json` - 主版本源文件
- `docs/icon-configuration.md` - 图标配置指南
- `scripts/create-tag.sh` - 标签创建脚本

---

**注意**: 修改版本系统时，请确保测试所有相关功能，避免破坏自动化流程。
#+end_src

#+begin_src md
# Git Hooks 版本系统快速指南

> 🤖 **AI 助手专用**: 如何正确配置自动版本号递增系统

## 🎯 核心原理

```
提交代码 → pre-commit hook → bump-version.sh → 更新版本文件 → 添加到当前提交
```

## 📁 关键文件

### 1. 控制文件
- `.git/hooks/pre-commit` - 触发器
- `scripts/bump-version.sh` - 版本更新逻辑

### 2. 版本源文件
- `package.json` - 主版本号 (唯一真实来源)

### 3. 需要同步的文件
```
package.json                                    # 主版本
apps/desktop/package.json                      # Desktop 应用
apps/web/package.json                          # Web 应用
apps/desktop/src-tauri/tauri.conf.json         # Tauri 配置
apps/desktop/src-tauri/Cargo.toml              # Rust 配置
aur/PKGBUILD                                   # Arch Linux
aur/PKGBUILD-binary                            # Arch Linux 二进制
snap/snapcraft.yaml                           # Snap 包
flatpak/com.lotus.NovelEditor.yml              # Flatpak 包
winget-manifests/*.yaml                        # Windows 包管理器
```

## 🔧 添加新文件到版本同步 (3 步骤)

### 步骤 1: 在 `scripts/bump-version.sh` 添加更新函数

```bash
# 根据文件格式选择模板:

# JSON 文件 (如 package.json)
update_json_version() {
    local file=$1
    local new_version=$2
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/\"version\":\s*\"[^\"]*\"/\"version\": \"$new_version\"/g" "$file"
    else
        sed -i "s/\"version\":\s*\"[^\"]*\"/\"version\": \"$new_version\"/g" "$file"
    fi
    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}

# YAML 文件 (如 snapcraft.yaml)
update_yaml_version() {
    local file=$1
    local new_version=$2
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^version: .*/version: '$new_version'/" "$file"
    else
        sed -i "s/^version: .*/version: '$new_version'/" "$file"
    fi
    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}

# TOML 文件 (如 Cargo.toml)
update_toml_version() {
    local file=$1
    local new_version=$2
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^version = \"[^\"]*\"/version = \"$new_version\"/" "$file"
    else
        sed -i "s/^version = \"[^\"]*\"/version = \"$new_version\"/" "$file"
    fi
    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}

# Shell 脚本 (如 PKGBUILD)
update_shell_version() {
    local file=$1
    local new_version=$2
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^pkgver=.*/pkgver=$new_version/" "$file"
    else
        sed -i "s/^pkgver=.*/pkgver=$new_version/" "$file"
    fi
    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

### 步骤 2: 在两个地方调用函数

在 `scripts/bump-version.sh` 中找到这两个部分并添加:

```bash
# A. 非静默模式 (约第 270 行，在 "# 10. Winget manifests" 后)
# 11. 新文件
update_newfile_version "$PROJECT_ROOT/path/to/newfile" "$NEW_VERSION" >&2

# B. 静默模式 (约第 285 行，在最后一行前)
update_newfile_version "$PROJECT_ROOT/path/to/newfile" "$NEW_VERSION" >/dev/null 2>&1
```

### 步骤 3: 在 `.git/hooks/pre-commit` 添加到暂存区

```bash
# 找到 git add 部分，添加新文件:
git add \
    package.json \
    apps/desktop/package.json \
    apps/web/package.json \
    apps/desktop/src-tauri/tauri.conf.json \
    apps/desktop/src-tauri/Cargo.toml \
    aur/PKGBUILD \
    aur/PKGBUILD-binary \
    snap/snapcraft.yaml \
    flatpak/com.lotus.NovelEditor.yml \
    winget-manifests/*.yaml \
    path/to/newfile \                    # 添加这行
    2>/dev/null || true
```

## 🚫 避免循环递增的关键点

### 1. 必须添加到暂存区
**所有被更新的版本文件都必须在 pre-commit hook 中添加到暂存区**

### 2. 跳过检测逻辑
如果新文件应该被识别为"版本文件"，更新检测正则:

```bash
# 在 .git/hooks/pre-commit 中找到这行并修改:
VERSION_FILES="package\.json|tauri\.conf\.json|Cargo\.toml|PKGBUILD|snapcraft\.yaml|winget-manifests/|newfile\.ext"
```

## 🔍 常见问题排查

### 问题: 文件被更新但循环提交
**原因**: 文件未添加到 pre-commit hook 的暂存区
**解决**: 在 `.git/hooks/pre-commit` 的 `git add` 部分添加该文件

### 问题: 版本号格式不正确
**原因**: sed 正则表达式不匹配文件格式
**解决**: 检查文件中版本号的确切格式，调整 sed 命令

### 问题: 某些文件版本号没有更新
**原因**: 更新函数未被调用或路径错误
**解决**: 检查函数调用和文件路径

## 🧪 测试新配置

```bash
# 1. 手动测试版本递增脚本
./scripts/bump-version.sh

# 2. 检查所有文件是否正确更新
grep -r "0\.1\." package.json apps/*/package.json aur/PKGBUILD* snap/snapcraft.yaml

# 3. 测试 pre-commit hook
echo "test" > test.txt
git add test.txt
git commit -m "test: verify version system"
rm test.txt
git add test.txt
git commit -m "cleanup: remove test file"
```

## 📋 文件格式示例

### JSON (package.json)
```json
{
  "version": "0.1.47"
}
```
**更新**: `"version": "0.1.47"` → `"version": "0.1.48"`

### YAML (snapcraft.yaml)
```yaml
version: '0.1.47'
```
**更新**: `version: '0.1.47'` → `version: '0.1.48'`

### TOML (Cargo.toml)
```toml
version = "0.1.47"
```
**更新**: `version = "0.1.47"` → `version = "0.1.48"`

### Shell (PKGBUILD)
```bash
pkgver=0.1.47
```
**更新**: `pkgver=0.1.47` → `pkgver=0.1.48`

## ⚡ 快速操作命令

```bash
# 跳过版本递增
SKIP_VERSION_BUMP=true git commit -m "docs: update only"

# 手动递增版本
npm run version:bump

# 检查当前版本
grep '"version"' package.json

# 查看暂存区状态
git diff --cached --name-only
```

---

**重要**: 每次修改版本系统后，务必测试完整的提交流程确保正常工作。
#+end_src

#+begin_src md
# 版本系统配置实例

> 📝 **实际示例**: 如何将新文件添加到自动版本号递增系统

## 🎯 示例场景

假设我们需要添加一个新的配置文件 `docker/docker-compose.yml`，它包含版本号信息：

```yaml
version: '3.8'
services:
  novel-editor:
    image: novel-editor:0.1.47  # 这里需要同步版本号
    ports:
      - "3000:3000"
```

## 📋 完整配置步骤

### 步骤 1: 在 `scripts/bump-version.sh` 添加更新函数

找到其他更新函数的位置（约第 130 行），添加：

```bash
# 函数：更新 Docker Compose 中的版本号
update_docker_version() {
    local file=$1
    local new_version=$2

    if [ ! -f "$file" ]; then
        echo -e "${YELLOW}警告: 文件不存在，跳过: $file${NC}"
        return 1
    fi

    # 更新 image 标签中的版本号
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/novel-editor:[0-9]\+\.[0-9]\+\.[0-9]\+/novel-editor:$new_version/" "$file"
    else
        sed -i "s/novel-editor:[0-9]\+\.[0-9]\+\.[0-9]\+/novel-editor:$new_version/" "$file"
    fi

    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

### 步骤 2: 在非静默模式中调用函数

找到非静默模式的更新部分（约第 270 行），在 `# 10. Winget manifests` 后添加：

```bash
        # 10. Winget manifests (仅更新版本号，不下载文件)
        update_winget_version "$NEW_VERSION" >&2

        # 11. Docker Compose 配置
        update_docker_version "$PROJECT_ROOT/docker/docker-compose.yml" "$NEW_VERSION" >&2
```

### 步骤 3: 在静默模式中调用函数

找到静默模式的更新部分（约第 285 行），在最后添加：

```bash
        update_snap_version "$PROJECT_ROOT/snap/snapcraft.yaml" "$NEW_VERSION" >/dev/null 2>&1
        update_flatpak_version "$PROJECT_ROOT/flatpak/com.lotus.NovelEditor.yml" "$NEW_VERSION" >/dev/null 2>&1
        update_winget_version "$NEW_VERSION" >/dev/null 2>&1
        update_docker_version "$PROJECT_ROOT/docker/docker-compose.yml" "$NEW_VERSION" >/dev/null 2>&1
```

### 步骤 4: 在 pre-commit hook 中添加到暂存区

编辑 `.git/hooks/pre-commit`，找到 `git add` 部分：

```bash
git add \
    package.json \
    apps/desktop/package.json \
    apps/web/package.json \
    apps/desktop/src-tauri/tauri.conf.json \
    apps/desktop/src-tauri/Cargo.toml \
    aur/PKGBUILD \
    aur/PKGBUILD-binary \
    snap/snapcraft.yaml \
    flatpak/com.lotus.NovelEditor.yml \
    winget-manifests/*.yaml \
    docker/docker-compose.yml \
    2>/dev/null || true
```

### 步骤 5: 更新跳过检测逻辑（可选）

如果希望只修改 Docker 文件时跳过版本递增，在 `.git/hooks/pre-commit` 中更新：

```bash
VERSION_FILES="package\.json|tauri\.conf\.json|Cargo\.toml|PKGBUILD|snapcraft\.yaml|winget-manifests/|docker-compose\.yml"
```

## 🧪 测试配置

### 1. 创建测试文件

```bash
mkdir -p docker
cat > docker/docker-compose.yml << EOF
version: '3.8'
services:
  novel-editor:
    image: novel-editor:0.1.47
    ports:
      - "3000:3000"
EOF
```

### 2. 手动测试版本递增

```bash
# 测试版本递增脚本
./scripts/bump-version.sh

# 检查文件是否正确更新
cat docker/docker-compose.yml
# 应该显示: image: novel-editor:0.1.48
```

### 3. 测试完整流程

```bash
# 添加文件到 git
git add docker/docker-compose.yml

# 提交测试（会触发 pre-commit hook）
git commit -m "feat: add docker configuration"

# 检查版本是否正确递增
grep "novel-editor:" docker/docker-compose.yml
```

## 🔍 验证结果

提交后，检查以下内容：

```bash
# 1. 检查主版本号是否递增
grep '"version"' package.json

# 2. 检查 Docker 文件是否更新
grep "novel-editor:" docker/docker-compose.yml

# 3. 检查其他文件是否同步
grep -r "0\.1\." package.json apps/*/package.json aur/PKGBUILD* snap/snapcraft.yaml docker/docker-compose.yml

# 4. 检查 git 状态
git status  # 应该显示 "nothing to commit, working tree clean"
```

## 📝 更多文件格式示例

### Dockerfile
```dockerfile
FROM node:18
LABEL version="0.1.47"
```

**更新函数**:
```bash
update_dockerfile_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/LABEL version=\"[^\"]*\"/LABEL version=\"$new_version\"/" "$file"
    else
        sed -i "s/LABEL version=\"[^\"]*\"/LABEL version=\"$new_version\"/" "$file"
    fi

    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

### Kubernetes Manifest
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: novel-editor
spec:
  template:
    spec:
      containers:
      - name: novel-editor
        image: novel-editor:0.1.47
```

**更新函数**:
```bash
update_k8s_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/image: novel-editor:[0-9]\+\.[0-9]\+\.[0-9]\+/image: novel-editor:$new_version/" "$file"
    else
        sed -i "s/image: novel-editor:[0-9]\+\.[0-9]\+\.[0-9]\+/image: novel-editor:$new_version/" "$file"
    fi

    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

### Python setup.py
```python
setup(
    name="novel-editor",
    version="0.1.47",
    description="Novel Editor"
)
```

**更新函数**:
```bash
update_python_version() {
    local file=$1
    local new_version=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/version=\"[^\"]*\"/version=\"$new_version\"/" "$file"
    else
        sed -i "s/version=\"[^\"]*\"/version=\"$new_version\"/" "$file"
    fi

    echo -e "${GREEN}✓${NC} 更新 $file -> $new_version"
}
```

## ⚠️ 常见错误和解决方案

### 错误 1: 文件更新但循环提交
```bash
# 问题: docker/docker-compose.yml 被更新但未添加到暂存区
# 解决: 确保在 .git/hooks/pre-commit 中添加了该文件
git add \
    # ... 其他文件 ...
    docker/docker-compose.yml \  # 必须添加这行
    2>/dev/null || true
```

### 错误 2: sed 命令不匹配
```bash
# 问题: 版本号格式与正则表达式不匹配
# 原文件: image: "novel-editor:0.1.47"  (有引号)
# sed 命令: s/novel-editor:[0-9]/novel-editor:$new_version/  (无引号匹配)

# 解决: 调整正则表达式
sed -i 's/novel-editor:"[^"]*"/novel-editor:"'$new_version'"/' "$file"
```

### 错误 3: 路径错误
```bash
# 问题: 文件路径不正确
update_docker_version "$PROJECT_ROOT/docker/docker-compose.yaml" "$NEW_VERSION"  # 错误: .yaml

# 解决: 检查实际文件扩展名
update_docker_version "$PROJECT_ROOT/docker/docker-compose.yml" "$NEW_VERSION"   # 正确: .yml
```

## 🎯 最佳实践总结

1. **函数命名**: 使用 `update_[类型]_version` 格式
2. **错误处理**: 检查文件是否存在
3. **跨平台**: 支持 macOS 和 Linux 的 sed 语法
4. **输出信息**: 提供清晰的成功/失败反馈
5. **测试验证**: 每次修改后都要测试完整流程
6. **文档更新**: 在相关文档中记录新增的文件

---

通过这个示例，你可以将任何包含版本号的文件添加到自动版本递增系统中。
#+end_src
